<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kataribe Browser Client</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .server-selector {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: #f9f9f9;
        }
        .controls {
            margin-bottom: 20px;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 4px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .status.connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }
        .log-entry.info { color: #17a2b8; }
        .log-entry.error { color: #dc3545; }
        .log-entry.success { color: #28a745; }
        input[type="text"], input[type="number"] {
            padding: 6px;
            margin: 4px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>ðŸš€ Kataribe Browser Client</h1>
    
    <div class="server-selector">
        <h3>Select Server Runtime</h3>
        <label>
            <input type="radio" name="runtime" value="nodejs-ws" checked>
            Node.js WebSocket (port 3000)
        </label><br>
        <label>
            <input type="radio" name="runtime" value="deno-ws">
            Deno WebSocket (port 3001)
        </label><br>
        <label>
            <input type="radio" name="runtime" value="bun-ws">
            Bun WebSocket (port 3002)
        </label><br>
        <label>
            <input type="radio" name="runtime" value="cloudflare-ws">
            Cloudflare Workers (port 8787)
        </label><br>
    </div>

    <div class="controls">
        <button id="connectBtn">Connect</button>
        <button id="disconnectBtn" disabled>Disconnect</button>
        <div id="status" class="status disconnected">Disconnected</div>
    </div>

    <div class="controls">
        <h3>RPC Tests</h3>
        <input type="number" id="numA" placeholder="Number A" value="2">
        <input type="number" id="numB" placeholder="Number B" value="3">
        <button id="addBtn" disabled>Add Numbers</button>
        <br>
        <input type="text" id="userId" placeholder="User ID" value="123">
        <button id="getUserBtn" disabled>Get User</button>
    </div>

    <h3>Log</h3>
    <div id="log" class="log"></div>

    <script type="module">
        // This would normally import from @kataribe/browser
        // For this demo, we'll implement a simple WebSocket client

        class SimpleKataribeClient {
            constructor() {
                this.ws = null;
                this.listeners = new Map();
                this.pendingRpcs = new Map();
                this.rpcId = 0;
            }

            async connect(url) {
                return new Promise((resolve, reject) => {
                    this.ws = new WebSocket(url);
                    
                    this.ws.onopen = () => {
                        this.log('Connected to ' + url, 'success');
                        // Send hello
                        this.send({
                            v: 1,
                            ts: Date.now(),
                            kind: 'hello',
                            feat: ['browser']
                        });
                        resolve();
                    };

                    this.ws.onerror = (error) => {
                        this.log('Connection error: ' + error, 'error');
                        reject(error);
                    };

                    this.ws.onmessage = (event) => {
                        const envelope = JSON.parse(event.data);
                        this.handleMessage(envelope);
                    };

                    this.ws.onclose = () => {
                        this.log('Disconnected', 'error');
                    };
                });
            }

            disconnect() {
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
            }

            send(envelope) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(envelope));
                }
            }

            async rpc(method, payload) {
                const id = (++this.rpcId).toString();
                const envelope = {
                    v: 1,
                    ts: Date.now(),
                    kind: 'rpc_req',
                    id,
                    ch: method,
                    p: payload
                };

                return new Promise((resolve, reject) => {
                    this.pendingRpcs.set(id, { resolve, reject });
                    this.send(envelope);

                    // Timeout after 10 seconds
                    setTimeout(() => {
                        if (this.pendingRpcs.has(id)) {
                            this.pendingRpcs.delete(id);
                            reject(new Error('RPC timeout'));
                        }
                    }, 10000);
                });
            }

            handleMessage(envelope) {
                switch (envelope.kind) {
                    case 'hello':
                        this.log('Server hello received', 'info');
                        break;
                    case 'rpc_res':
                        this.handleRpcResponse(envelope);
                        break;
                    case 'rpc_err':
                        this.handleRpcError(envelope);
                        break;
                    case 'event':
                        this.handleEvent(envelope);
                        break;
                    case 'rpc_req':
                        this.handleRpcRequest(envelope);
                        break;
                }
            }

            handleRpcResponse(envelope) {
                const pending = this.pendingRpcs.get(envelope.id);
                if (pending) {
                    this.pendingRpcs.delete(envelope.id);
                    pending.resolve(envelope.p);
                }
            }

            handleRpcError(envelope) {
                const pending = this.pendingRpcs.get(envelope.id);
                if (pending) {
                    this.pendingRpcs.delete(envelope.id);
                    pending.reject(new Error(envelope.m || 'RPC error'));
                }
            }

            handleEvent(envelope) {
                this.log(`Event [${envelope.ch}]: ${JSON.stringify(envelope.p)}`, 'info');
            }

            handleRpcRequest(envelope) {
                // Handle server->client RPC calls
                if (envelope.ch === 'notifyClient') {
                    this.log(`Server notification: ${envelope.p.message}`, 'info');
                    // Send response
                    this.send({
                        v: 1,
                        ts: Date.now(),
                        kind: 'rpc_res',
                        id: envelope.id,
                        ch: envelope.ch,
                        p: { received: true }
                    });
                }
            }

            log(message, type = 'info') {
                const logDiv = document.getElementById('log');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                logDiv.appendChild(entry);
                logDiv.scrollTop = logDiv.scrollHeight;
            }
        }

        const client = new SimpleKataribeClient();
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const statusDiv = document.getElementById('status');
        const addBtn = document.getElementById('addBtn');
        const getUserBtn = document.getElementById('getUserBtn');

        function getSelectedPort() {
            const selected = document.querySelector('input[name="runtime"]:checked').value;
            const ports = {
                'nodejs-ws': 3000,
                'deno-ws': 3001,
                'bun-ws': 3002,
                'cloudflare-ws': 8787
            };
            return ports[selected];
        }

        function setConnected(connected) {
            connectBtn.disabled = connected;
            disconnectBtn.disabled = !connected;
            addBtn.disabled = !connected;
            getUserBtn.disabled = !connected;
            statusDiv.textContent = connected ? 'Connected' : 'Disconnected';
            statusDiv.className = connected ? 'status connected' : 'status disconnected';
        }

        connectBtn.addEventListener('click', async () => {
            try {
                const port = getSelectedPort();
                await client.connect(`ws://localhost:${port}`);
                setConnected(true);
            } catch (error) {
                client.log('Failed to connect: ' + error.message, 'error');
            }
        });

        disconnectBtn.addEventListener('click', () => {
            client.disconnect();
            setConnected(false);
        });

        addBtn.addEventListener('click', async () => {
            try {
                const a = parseInt(document.getElementById('numA').value);
                const b = parseInt(document.getElementById('numB').value);
                const result = await client.rpc('add', { a, b });
                client.log(`Add result: ${a} + ${b} = ${result.sum}`, 'success');
            } catch (error) {
                client.log('Add RPC failed: ' + error.message, 'error');
            }
        });

        getUserBtn.addEventListener('click', async () => {
            try {
                const id = document.getElementById('userId').value;
                const result = await client.rpc('getUser', { id });
                client.log(`User: ${result.name} (${result.id})`, 'success');
            } catch (error) {
                client.log('GetUser RPC failed: ' + error.message, 'error');
            }
        });

        // Initial log message
        client.log('Browser client ready. Select a runtime and click Connect.', 'info');
    </script>
</body>
</html>